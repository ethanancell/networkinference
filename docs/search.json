[{"path":"https://ethanancell.github.io/networkinference/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Ethan Ancell Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://ethanancell.github.io/networkinference/articles/network-inference-vignette.html","id":"necessary-packages-for-this-vignette","dir":"Articles","previous_headings":"","what":"Necessary packages for this vignette","title":"Getting started with the networkinference R package","text":"","code":"library(networkinference) # Package implementing the methods of this paper library(nett) # For spectral clustering library(RSpectra) # Dependency of nett package  set.seed(1234) # Reproducibility"},{"path":[]},{"path":"https://ethanancell.github.io/networkinference/articles/network-inference-vignette.html","id":"networks-with-gaussian-edges","dir":"Articles","previous_headings":"Examples","what":"Networks with Gaussian edges","title":"Getting started with the networkinference R package","text":"Suppose observe network n = 60 nodes. Gaussian setting, edges encoded adjacency matrix obey A_{ij} \\overset{\\text{ind.}}{\\sim} N(M_{ij}, \\tau^2), treat M_{ij} unknown \\tau^2 known. Let us simulate adjacency matrix setting three “true communities,” intra-community connectivity \\rho_1 = 25, inter-community connectivity \\rho_2 = 18, known edge variance \\tau^2 = 4^2. Visualizing adjacency matrix image (rows run top bottom, columns run left right), can see greater density connections within communities communities.  Now, let’s use split_network() function package split adjacency matrix train test adjacency matrices. arguments, must provide distributional setting (Gaussian), splitting parameter \\epsilon = 0.5, well known variance \\tau^2 = 4^2.  Now, let us conduct community estimation using Atr using K=4 communities. (Note misspecified number communities!) Let’s now try conduct inference mean intra-community connectivity within 1st estimated community. , want set appropriate linear combination vector u length K^2, K number estimated communities. resulting gaussian_inference contains two pieces, estimate gaussian_inference$estimate (\\hat{\\theta}(^{(\\text{tr})}) accompanying paper), well estimate variance gaussian_inference$estimate_variance (\\hat{\\sigma}^2 accompanying paper). case, find \\hat{\\theta}(^{(\\text{tr})}) = 24.1638, \\quad \\hat{\\sigma}^2 = 0.0726. , can construct 90% confidence interval target following: simulated data , can check whether confidence interval actually contained true target inference.","code":"# Some global information n <- 60 n_per_community <- 20 tau <- 4 # Known standard deviation of the edges rho_1 <- 25 # Intra-community connectivity rho_2 <- 18 # Inter-community connectivity  # Build tiles which we will use to construct our mean matrix M intra_comm <- matrix(rep(rho_1, n_per_community^2), nrow = n_per_community) inter_comm <- matrix(rep(rho_2, n_per_community^2), nrow = n_per_community)  # Construct mean matrix M <- rbind(cbind(intra_comm, inter_comm, inter_comm),            cbind(inter_comm, intra_comm, inter_comm),            cbind(inter_comm, inter_comm, intra_comm))  # Draw a network using this mean matrix A <- matrix(rnorm(n = n^2, mean = as.vector(M), sd = tau), nrow = n) par(mar = c(0.5, 0.5, 0.5, 0.5)) par(pty = \"s\") image(t(A[nrow(A):1,]), axes = FALSE, asp = 1) gaussian_split_results <- split_network(A, distribution = \"gaussian\",                                          epsilon = 0.5, tau = tau) Atr <- gaussian_split_results$Atr Ate <- gaussian_split_results$Ate  # Visualize both the Atr and Ate matrices layout(matrix(1, 2, nrow = 1)) par(mfrow = c(1, 2), mar = c(1, 1, 1, 1)) image(t(Atr[nrow(Atr):1,]), axes = FALSE, asp = 1) title(\"Train network\") image(t(Ate[nrow(Ate):1,]), axes = FALSE, asp = 1) title(\"Test network\") estimated_communities <- nett::spec_clust(Atr, K = 4) estimated_communities # A vector specifying each node's estimated community #>  [1] 2 2 2 2 2 4 4 4 4 2 2 2 2 2 2 4 2 4 2 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 #> [39] 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 u_vector <- c(1, 0, 0, 0,                0, 0, 0, 0,                0, 0, 0, 0,               0, 0, 0, 0)  # Conduct inference for the selected target (mean connectivity within the # first estimated community) gaussian_inference <-   infer_network(Ate = Ate, u = u_vector,                 communities = estimated_communities,                 distribution = \"gaussian\",                 epsilon = 0.5, tau = tau) alpha <- 0.10 margin_of_error <- qnorm(1 - alpha/2) * sqrt(gaussian_inference$estimate_variance) ci_lower_bound <- gaussian_inference$estimate - margin_of_error ci_upper_bound <- gaussian_inference$estimate + margin_of_error  print(paste0(\"Estimate of selected target is \", round(gaussian_inference$estimate, 4))) #> [1] \"Estimate of selected target is 24.1638\" print(paste0(\"Confidence interval for selected target is [\",              round(ci_lower_bound, 4), \", \", round(ci_upper_bound, 4), \"]\")) #> [1] \"Confidence interval for selected target is [23.7207, 24.6068]\" true_target <- check_target_of_inference(M = M, u = u_vector,                                          communities = estimated_communities) true_target_contained <- (ci_lower_bound <= true_target) &    (true_target <= ci_upper_bound)  # Print results print(paste0(\"True target of inference is \", round(true_target, 4))) #> [1] \"True target of inference is 24.3651\" print(\"Did the 90% confidence interval contain the true target of inference?\") #> [1] \"Did the 90% confidence interval contain the true target of inference?\" print(paste0(\"-> \", as.character(true_target_contained))) #> [1] \"-> TRUE\""},{"path":"https://ethanancell.github.io/networkinference/articles/network-inference-vignette.html","id":"networks-with-bernoulli-edges","dir":"Articles","previous_headings":"Examples","what":"Networks with Bernoulli edges","title":"Getting started with the networkinference R package","text":", consider setting n=60 nodes. Bernoulli setting, assume A_{ij} \\overset{\\text{ind.}}{\\sim} \\text{Bernoulli}(M_{ij}), M_{ij} unknown. Let us simulate setting three “true communities,” intra-community connectivity \\rho_1 = 0.80, inter-community connectivity \\rho_2 = 0.40. Visualizing adjacency matrix image (rows run top bottom, columns run left right), can see greater density connections within communities communities. contrast Gaussian adjacency matrix , edge connections unweighted (binary) rather weighted (continuous integer-valued).  Now, can use split_network() function package split train test adjacency matrices. split parameter \\gamma = 0.15, pass gamma = 0.15 function, specify distributional setting.  Now, let us conduct community estimation using Atr using K=4 communities. (Note misspecified number communities!) Let’s now try conduct inference mean intra-community connectivity within 1st estimated community. , want set appropriate linear combination vector u length K^2, K number estimated communities. resulting object bernoulli_inference contains two pieces, estimate bernoulli_inference$estimate (\\hat{\\xi}(^{(\\text{tr})}) paper), well estimate variance bernoulli_inference$estimate_variance (\\hat{\\sigma}^2 paper). case, find \\hat{\\xi}(^{(\\text{tr})}) = 0.522, \\quad \\hat{\\sigma}^2 = 0.0012. Thus, construct 90% confidence interval following: simulated data , can check matches true targets interest, \\theta(^{(\\text{tr})}) \\xi(^{(\\text{tr})}). Please see accompanying paper reminder differences two targets. case, find \\theta(^{(\\text{tr})}) = 0.582, \\quad \\xi(^{(\\text{tr})}) = 0.5742.","code":"n <- 60 n_per_community <- 20 rho_1 <- 0.80 rho_2 <- 0.40  # Used to construct the mean matrix intra_comm <- matrix(rep(rho_1, n_per_community^2), nrow = n_per_community) inter_comm <- matrix(rep(rho_2, n_per_community^2), nrow = n_per_community)  # Construct mean matrix M <- rbind(cbind(intra_comm, inter_comm, inter_comm),            cbind(inter_comm, intra_comm, inter_comm),            cbind(inter_comm, inter_comm, intra_comm))  # Draw a network using this mean matrix A <- matrix(rbinom(n = n^2, size = 1, prob = as.vector(M)), nrow = n) par(mar = c(0.5, 0.5, 0.5, 0.5)) par(pty = \"s\") image(t(A[nrow(A):1,]), axes = FALSE, asp = 1) bernoulli_split_results <- split_network(A, distribution = \"bernoulli\",                                          gamma = 0.15) Atr <- bernoulli_split_results$Atr Ate <- bernoulli_split_results$Ate  # Visualize both the Atr and Ate matrices layout(matrix(1, 2, nrow = 1)) par(mfrow = c(1, 2), mar = c(1, 1, 1, 1)) image(t(Atr[nrow(Atr):1,]), axes = FALSE, asp = 1) title(\"Train network\") image(t(Ate[nrow(Ate):1,]), axes = FALSE, asp = 1) title(\"Test network\") estimated_communities <- nett::spec_clust(Atr, K = 4) estimated_communities # A vector specifying each node's estimated community #>  [1] 1 3 4 1 3 1 2 1 1 1 4 1 3 1 1 3 4 3 1 2 1 3 3 1 1 3 3 3 3 1 1 3 1 3 3 1 4 1 #> [39] 2 1 3 3 4 4 3 4 4 2 2 4 3 2 4 2 4 1 4 4 4 4 u_vector <- c(1, 0, 0, 0,                0, 0, 0, 0,                0, 0, 0, 0,               0, 0, 0, 0)  # Conduct inference for the selected target (mean connectivity within the # first estimated community) bernoulli_inference <-   infer_network(Ate = Ate, u = u_vector,                 communities = estimated_communities,                 distribution = \"bernoulli\",                 Atr = Atr,                 gamma = 0.15) alpha <- 0.10 margin_of_error <- qnorm(1 - alpha/2) * sqrt(bernoulli_inference$estimate_variance) ci_lower_bound <- bernoulli_inference$estimate - margin_of_error ci_upper_bound <- bernoulli_inference$estimate + margin_of_error  print(paste0(\"Confidence interval for selected target is [\",              round(ci_lower_bound, 4), \", \", round(ci_upper_bound, 4), \"]\")) #> [1] \"Confidence interval for selected target is [0.4648, 0.5793]\" true_target_theta <- check_target_of_inference(M = M, u = u_vector,                                                communities = estimated_communities) true_target_xi <- check_target_of_inference(M = M, u = u_vector,                                             communities = estimated_communities,                                             bernoulli_target = TRUE,                                             gamma = 0.15, Atr = Atr)"},{"path":"https://ethanancell.github.io/networkinference/articles/network-inference-vignette.html","id":"undirected-networks-and-networks-without-self-loops","dir":"Articles","previous_headings":"Examples","what":"Undirected networks and networks without self-loops","title":"Getting started with the networkinference R package","text":"working undirected networks, edge linking node j synonymous edge linking node j . networkinference package, upper triangular portions adjacency matrices undirected networks used. Crucially, linear combination vector u must also correspond upper triangular matrix. networks allow self-loops, values along diagonal adjacency matrix ignored. simple example involving undirected Poisson network allow self-loops. Visualizing adjacency matrix image (rows run top bottom, columns run left right), can see greater density connections within communities communities.  Now, let’s use split_network() function package split adjacency matrix train test adjacency matrices. arguments, must provide distributional setting (Poisson), splitting parameter \\epsilon = 0.5.  Now, let us conduct community estimation using Atr using K=2 communities. Let’s conduct inference difference connectivity within estimated communities connectivity communities. , want set appropriate linear combination vector u length K^2, K number estimated communities. network undirected, u must upper triangular. Now, let’s create 90% confidence interval selected parameter.","code":"n <- 60 n_per_community <- 30 rho_1 <- 25 # Intra-community connectivity rho_2 <- 18 # Inter-community connectivity  # Build tiles which we will use to construct our mean matrix M zeros_block <- matrix(rep(0, n_per_community^2), nrow = n_per_community) intra_comm <- matrix(rep(0, n_per_community^2), nrow = n_per_community) intra_comm[upper.tri(intra_comm, diag = FALSE)] <- rho_1 inter_comm <- matrix(rep(rho_2, n_per_community^2), nrow = n_per_community)  # Construct mean matrix M <- rbind(cbind(intra_comm, inter_comm),            cbind(zeros_block, intra_comm))  # Draw a network using this mean matrix A <- matrix(rpois(n = n^2, lambda = as.vector(M)), nrow = n) par(mar = c(0.5, 0.5, 0.5, 0.5)) par(pty = \"s\") image(t(A[nrow(A):1,]), axes = FALSE, asp = 1) poisson_split_results <- split_network(A, distribution = \"poisson\",                                         epsilon = 0.5, is_directed = FALSE,                                        allow_self_loops = FALSE) Atr <- poisson_split_results$Atr Ate <- poisson_split_results$Ate  # Visualize both the Atr and Ate matrices layout(matrix(1, 2, nrow = 1)) par(mfrow = c(1, 2), mar = c(1, 1, 1, 1)) image(t(Atr[nrow(Atr):1,]), axes = FALSE, asp = 1) title(\"Train network\") image(t(Ate[nrow(Ate):1,]), axes = FALSE, asp = 1) title(\"Test network\") # Importantly, note that nett:spec_clust wants your matrix to be symmetric, # not just upper triangular. Atr_symm <- Atr + t(Atr) estimated_communities <- nett::spec_clust(Atr_symm, K = 2) estimated_communities # A vector specifying each node's estimated community #>  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 #> [39] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 # Note that matrix(u_vector, nrow = 2) would be upper triangular! u_vector <- c(1, 0, -2, 1)  # Normalize it u_vector <- u_vector / sqrt(sum(u_vector^2))  # Conduct inference for the selected target (mean connectivity within the # first estimated community) poisson_inference <-   infer_network(Ate = Ate, u = u_vector,                 communities = estimated_communities,                 distribution = \"poisson\",                 epsilon = 0.5, is_directed = FALSE,                 allow_self_loops = FALSE) alpha <- 0.10 margin_of_error <- qnorm(1 - alpha/2) * sqrt(poisson_inference$estimate_variance) ci_lower_bound <- poisson_inference$estimate - margin_of_error ci_upper_bound <- poisson_inference$estimate + margin_of_error  print(paste0(\"Confidence interval for selected target is [\",              round(ci_lower_bound, 4), \", \", round(ci_upper_bound, 4), \"]\")) #> [1] \"Confidence interval for selected target is [5.7415, 6.4455]\""},{"path":"https://ethanancell.github.io/networkinference/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Ethan Ancell. Maintainer.","code":""},{"path":"https://ethanancell.github.io/networkinference/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ancell E (2025). networkinference: Post-selection inference single realization network. R package version 0.1.0, https://ethanancell.github.io/networkinference/.","code":"@Manual{,   title = {networkinference: Post-selection inference with a single realization of a network},   author = {Ethan Ancell},   year = {2025},   note = {R package version 0.1.0},   url = {https://ethanancell.github.io/networkinference/}, }"},{"path":"https://ethanancell.github.io/networkinference/index.html","id":"post-selection-inference-with-a-single-realization-of-a-network","dir":"","previous_headings":"","what":"Post-selection inference with a single realization of a network","title":"Post-selection inference with a single realization of a network","text":"networkinference R package implements methods ``Post-selection inference single realization network’’ Ethan Ancell, Daniela Witten, Daniel Kessler. Suppose observe network n nodes, encoded adjacency matrix \\\\mathbb{R}^{n \\times n} A_{ij} encodes edge node node j. network unweighted, A_{ij} = 1 edge node node j, A_{ij} = 0 otherwise. network weighted, A_{ij} weight edge pointing node node j. network undirected, A_{ij} = A_{ji} j. setting random networks: particular, assume one following holds: A_{ij} \\overset{\\text{ind.}}{\\sim} N(M_{ij}, \\sigma^2), \\sigma^2 known A_{ij} \\overset{\\text{ind.}}{\\sim} \\text{Poisson}(M_{ij}) A_{ij} \\overset{\\text{ind.}}{\\sim} \\text{Bernoulli}(M_{ij}) package associated paper considers setting user wishes Estimate latent communities network based upon adjacency matrix. Conduct inference connectivity parameter function estimated communities. particular, consider connectivity parameter linear combination average connectivity within estimated communities. step (2) valid, must take account selected parameter function data, coverage confidence intervals must hold conditional selection communities. accomplish , “split” adjacency matrix \\\\mathbb{R}^{n \\times n} two adjacency matrices ^{(\\text{tr})}, ^{(\\text{te})} \\\\mathbb{R}^{n \\times n} using networkinference::split_network() function. , user may use method choice estimate communities \\hat{Z} = \\hat{Z}(^{(\\text{tr})}) \\\\{0,1\\}^{n \\times K} \\hat{Z}_{ik} = 1 ith node belongs kth estimated community, \\hat{Z}_{ik} = 0 otherwise. Critically, \\hat{Z} must function ^{(\\text{tr})}. Finally, conduct inference selected parameter using networkinference::infer_network() function.","code":""},{"path":"https://ethanancell.github.io/networkinference/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Post-selection inference with a single realization of a network","text":"end--end example running features R package, please read vignette.","code":""},{"path":"https://ethanancell.github.io/networkinference/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Post-selection inference with a single realization of a network","text":"install networkinference package, run devtools::install_github(\"ethanancell/networkinference\") R console.","code":""},{"path":"https://ethanancell.github.io/networkinference/index.html","id":"figures-in-paper","dir":"","previous_headings":"","what":"Figures in paper","title":"Post-selection inference with a single realization of a network","text":"link Github repository contains scripts used generate figures paper.","code":""},{"path":"https://ethanancell.github.io/networkinference/reference/check_target_of_inference.html","id":null,"dir":"Reference","previous_headings":"","what":"In simulation settings where the true mean matrix is known and a set of estimated communities are provided, this function returns the true target of inference. — check_target_of_inference","title":"In simulation settings where the true mean matrix is known and a set of estimated communities are provided, this function returns the true target of inference. — check_target_of_inference","text":"simulation settings true mean matrix known set estimated communities provided, function returns true target inference.","code":""},{"path":"https://ethanancell.github.io/networkinference/reference/check_target_of_inference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"In simulation settings where the true mean matrix is known and a set of estimated communities are provided, this function returns the true target of inference. — check_target_of_inference","text":"","code":"check_target_of_inference(   M,   u,   communities,   allow_self_loops = TRUE,   is_directed = TRUE,   bernoulli_target = FALSE,   gamma = NULL,   Atr = NULL )"},{"path":"https://ethanancell.github.io/networkinference/reference/check_target_of_inference.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"In simulation settings where the true mean matrix is known and a set of estimated communities are provided, this function returns the true target of inference. — check_target_of_inference","text":"M true mean matrix. u linear combination vector (matrix) specifies connectivity parameters considered constructing selected target inference. input norm 1. `is_directed` set `FALSE`, matrix version `u` must upper triangular. communities vector matrix specifies estimated communities. inputted vector, `M` size `n` x `n`, vector length `n`, ith element numbered community ith node belongs . example, `communities[2] = 3` indicate 2nd node belongs 3rd estimated community. inputted matrix, matrix 0s 1s , `communities[, k] = 1` indicates ith node belongs kth community. node allowed belong single community, single 1 row matrix. allow_self_loops logical indicating whether network allows self loops (edges pointing node .) default parameter set `TRUE`. set `FALSE`, values along diagonal input `M` ignored. is_directed logical indicating whether network directed network, default set `TRUE`. set `FALSE`, values upper triangular portion `M` used. bernoulli_target logical indicating whether calculate alternative target Bernoulli networks specified paper close actual target interest. set `TRUE`, argument `Atr` must also provided. gamma Bernoulli networks, parameter controlling amount information allocated train network versus test network. must 0 0.5 (non-inclusive) larger value `gamma` indicates less information train network, test network. Atr matrix size `M` arising `split_network()` function. argument used `bernoulli_target` argument set `TRUE`.","code":""},{"path":"https://ethanancell.github.io/networkinference/reference/check_target_of_inference.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"In simulation settings where the true mean matrix is known and a set of estimated communities are provided, this function returns the true target of inference. — check_target_of_inference","text":"single numeric true target inference sought.","code":""},{"path":"https://ethanancell.github.io/networkinference/reference/check_target_of_inference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"In simulation settings where the true mean matrix is known and a set of estimated communities are provided, this function returns the true target of inference. — check_target_of_inference","text":"","code":"# As an example, let's build our matrix M to be a 10x10 matrix where each # element is sampled uniformly from a Uniform(0, 1) distribution. M <- matrix(stats::runif(n = 10^2), nrow = 10)  # Set our \"estimated_communities\" to just have the first 5 nodes in the first # community, and the last 5 nodes in the other community communities_estimate <- c(1, 1, 1, 1, 1, 2, 2, 2, 2, 2)  # This choice of \"u\" vector would be conducting inference for the mean # connectivity within the first estimated community. u_vector <- c(1, 0,               0, 0)  # Conduct inference for the selected target (mean connectivity within the # first estimated community) target_of_inference <-   check_target_of_inference(M = M, u = u_vector,                             communities = communities_estimate,                             allow_self_loops = TRUE, is_directed = TRUE)"},{"path":"https://ethanancell.github.io/networkinference/reference/infer_network.html","id":null,"dir":"Reference","previous_headings":"","what":"Conduct inference using `Ate` for the selected target of inference: a linear combination of connectivity parameters based upon estimated communities. Note that communities should be estimated using the `Atr` matrix produced from the `split_network()` function prior to using this function. — infer_network","title":"Conduct inference using `Ate` for the selected target of inference: a linear combination of connectivity parameters based upon estimated communities. Note that communities should be estimated using the `Atr` matrix produced from the `split_network()` function prior to using this function. — infer_network","text":"Conduct inference using `Ate` selected target inference: linear combination connectivity parameters based upon estimated communities. Note communities estimated using `Atr` matrix produced `split_network()` function prior using function.","code":""},{"path":"https://ethanancell.github.io/networkinference/reference/infer_network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conduct inference using `Ate` for the selected target of inference: a linear combination of connectivity parameters based upon estimated communities. Note that communities should be estimated using the `Atr` matrix produced from the `split_network()` function prior to using this function. — infer_network","text":"","code":"infer_network(   Ate,   u,   communities,   distribution,   epsilon = 0.5,   gamma = NULL,   Atr = NULL,   allow_self_loops = TRUE,   is_directed = TRUE,   tau = NULL )"},{"path":"https://ethanancell.github.io/networkinference/reference/infer_network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conduct inference using `Ate` for the selected target of inference: a linear combination of connectivity parameters based upon estimated communities. Note that communities should be estimated using the `Atr` matrix produced from the `split_network()` function prior to using this function. — infer_network","text":"Ate test adjacency matrix produced `split_network()` function used conduct inference. u linear combination vector (matrix) specifies connectivity parameters considered constructing selected target inference. input norm 1. `is_directed` set `FALSE`, matrix version `u` must upper triangular. communities vector matrix specifies estimated communities. inputted vector, `Ate` size `n` x `n`, vector length `n`, ith element numbered community ith node belongs . example, `communities[2] = 3` indicate 2nd node belongs 3rd estimated community. inputted matrix, matrix size `n` x `K`, `K` number estimated communities. matrix 0s 1s , `communities[, k] = 1` indicates ith node belongs `k`th community. node allowed belong single community, single 1 row matrix. distribution distribution edges adjacency matrix follow. Acceptable distributions `\"gaussian\"`, `\"poisson\"`, `\"bernoulli\"`. epsilon parameter controlling amount information allocated train network versus test network. Gaussian Poisson networks, must 0 1 (non-inclusive). larger value epsilon indicates information train network. Bernoulli networks, input alias `gamma` parameter. gamma Bernoulli networks, parameter controlling amount information allocated train network versus test network. must 0 0.5 (non-inclusive) larger value `gamma` indicates less information train network, test network. Atr train adjacency matrix produced `split_network()` function. necessary network edges follow Bernoulli distribution. allow_self_loops logical indicating whether network allows self loops (edges pointing node .) default parameter set `TRUE`. set `FALSE`, values adjacency matrix along diagonal ignored. is_directed logical indicating whether network directed network, default set `TRUE`. set `FALSE`, values upper triangular portion adjacency matrix used. tau networks Gaussian edges , parameter indicates known common standard deviation (square root variance) edges network.","code":""},{"path":"https://ethanancell.github.io/networkinference/reference/infer_network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conduct inference using `Ate` for the selected target of inference: a linear combination of connectivity parameters based upon estimated communities. Note that communities should be estimated using the `Atr` matrix produced from the `split_network()` function prior to using this function. — infer_network","text":"list labeled two elements labeled `\"estimate\"` `\"estimate_variance\"`, contain estimate selected target inference, well estimate variance estimator.","code":""},{"path":"https://ethanancell.github.io/networkinference/reference/infer_network.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conduct inference using `Ate` for the selected target of inference: a linear combination of connectivity parameters based upon estimated communities. Note that communities should be estimated using the `Atr` matrix produced from the `split_network()` function prior to using this function. — infer_network","text":"","code":"# ============================== # == Gaussian network example == # ============================== # (Poisson networks proceed nearly identically except that the parameter #  tau is not necessary to input into split_network() or infer_network())  # First, split a simulated Gaussian adjacency matrix A_gaussian <- matrix(stats::rnorm(n = 10^2, mean = 10, sd = 5), nrow = 10) gaussian_split <- split_network(A = A_gaussian, distribution = \"gaussian\",                                epsilon = 0.3, tau = 5) A_gaussian_tr <- gaussian_split$Atr A_gaussian_te <- gaussian_split$Ate  # Estimate some communities using the train matrix using spectral # clustering for K=3 communities if (requireNamespace(\"nett\", quietly = TRUE)) {   communities_estimate <- nett::spec_clust(A_gaussian_tr, K = 3) } else {   communities_estimate <- c(1, 1, 1, 2, 2, 2, 3, 3, 3, 3) }  # This particular \"u\" vector will specify that we want to conduct inference # for the mean connectivity within the first estimated community. # Note that \"u\" is of length 9, because we have 3 estimated communities. # (This should always be of length K^3) u_vector <- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0)  # We can also specify \"u\" in matrix form. u_matrix <- matrix(c(1, 0, 0,                      0, 0, 0,                      0, 0, 0), nrow = 3)  # Conduct inference for the selected target (mean connectivity within the # first estimated community) gaussian_inference <-     infer_network(Ate = A_gaussian_te, u = u_matrix,                   communities = communities_estimate,                   distribution = \"gaussian\",                   epsilon = 0.3, tau = 5)  # Produce a 90% confidence interval for the target of inference margin_of_error <- sqrt(gaussian_inference$estimate_variance) * qnorm(0.95) ci_upper_bound <- gaussian_inference$estimate + margin_of_error ci_lower_bound <- gaussian_inference$estimate - margin_of_error  # =============================== # == Bernoulli network example == # ===============================  # First, split a simulated Bernoulli adjacency matrix with gamma=0.10 A_bernoulli <- matrix(stats::rbinom(n = 10^2, size = 1, p = 0.5), nrow = 10) bernoulli_split <- split_network(A = A_bernoulli, distribution = \"bernoulli\",                                 gamma = 0.10) A_bernoulli_tr <- bernoulli_split$Atr A_bernoulli_te <- bernoulli_split$Ate  # Estimate some communities using the train matrix using spectral # clustering for K=3 communities if (requireNamespace(\"nett\", quietly = TRUE)) {   communities_estimate <- nett::spec_clust(A_bernoulli_tr, K = 3) } else {   communities_estimate <- c(1, 1, 1, 2, 2, 2, 3, 3, 3, 3) }  # This particular \"u\" vector will specify that we want to conduct inference # for the mean connectivity within the first estimated community. # Note that \"u\" is of length 9, because we have 3 estimated communities. # (This should always be of length K^3) u_vector <- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0)  # We can also specify \"u\" in matrix form. u_matrix <- matrix(c(1, 0, 0,                      0, 0, 0,                      0, 0, 0), nrow = 3)  # Conduct inference for the selected target (mean connectivity within the # first estimated community) bernoulli_inference <-     infer_network(Ate = A_bernoulli_te, u = u_matrix,                   communities = communities_estimate,                   distribution = \"bernoulli\",                   gamma = 0.10, Atr = A_bernoulli_tr)  # Produce a 90% confidence interval for the target of inference margin_of_error <- sqrt(bernoulli_inference$estimate_variance) * qnorm(0.95) ci_upper_bound <- bernoulli_inference$estimate + margin_of_error ci_lower_bound <- bernoulli_inference$estimate - margin_of_error"},{"path":"https://ethanancell.github.io/networkinference/reference/split_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Split an adjacency matrix into a train and test adjacency matrix using either data thinning (Poisson or Gaussian edges) or data fission (Bernoulli edges.) — split_matrix","title":"Split an adjacency matrix into a train and test adjacency matrix using either data thinning (Poisson or Gaussian edges) or data fission (Bernoulli edges.) — split_matrix","text":"Split adjacency matrix train test adjacency matrix using either data thinning (Poisson Gaussian edges) data fission (Bernoulli edges.)","code":""},{"path":"https://ethanancell.github.io/networkinference/reference/split_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split an adjacency matrix into a train and test adjacency matrix using either data thinning (Poisson or Gaussian edges) or data fission (Bernoulli edges.) — split_matrix","text":"","code":"split_matrix(   A,   distribution,   epsilon = 0.5,   gamma = NULL,   allow_self_loops = TRUE,   is_directed = TRUE,   tau = NULL )"},{"path":"https://ethanancell.github.io/networkinference/reference/split_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split an adjacency matrix into a train and test adjacency matrix using either data thinning (Poisson or Gaussian edges) or data fission (Bernoulli edges.) — split_matrix","text":"square adjacency matrix split. distribution distribution edges adjacency matrix follow. Acceptable distributions `\"gaussian\"`, `\"poisson\"`, `\"bernoulli\"`. epsilon parameter controlling amount information allocated train network versus test network. Gaussian Poisson networks, larger value `epsilon` indicates information train network. Bernoulli networks, input alias `gamma` parameter. gamma Bernoulli networks, parameter controlling amount information allocated train network versus test network. larger value `gamma` indicates less information train network, test network. allow_self_loops logical indicating whether network allows self loops (edges pointing node .) default parameter set `TRUE`. set `FALSE`, values adjacency matrix along diagonal ignored. is_directed logical indicating whether network directed network, default set `TRUE`. set `FALSE`, values along upper triangular portion matrix used. tau networks Gaussian edges , parameter indicates known common standard deviation (square root variance) edges network.","code":""},{"path":"https://ethanancell.github.io/networkinference/reference/split_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split an adjacency matrix into a train and test adjacency matrix using either data thinning (Poisson or Gaussian edges) or data fission (Bernoulli edges.) — split_matrix","text":"list labeled two elements labeled `\"Atr\"` `\"Ate\"`, train test networks, respectively.","code":""},{"path":"https://ethanancell.github.io/networkinference/reference/split_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split an adjacency matrix into a train and test adjacency matrix using either data thinning (Poisson or Gaussian edges) or data fission (Bernoulli edges.) — split_matrix","text":"","code":"# Split a simulated Gaussian adjacency matrix A_gaussian <- matrix(rnorm(n = 10^2, mean = 10, sd = 5), nrow = 10) gaussian_split <- split_matrix(A_gaussian, \"gaussian\", 0.3, tau = 5) A_gaussian_tr <- gaussian_split$Atr A_gaussian_te <- gaussian_split$Ate  # Split a simulated Bernoulli adjacency matrix with gamma = 0.25 A_bernoulli <- matrix(rbinom(n = 10^2, size = 1, p = 0.5), nrow = 10) bernoulli_split <- split_matrix(A_bernoulli, \"bernoulli\", gamma = 0.25) A_bernoulli_tr <- bernoulli_split$Atr A_bernoulli_te <- bernoulli_split$Ate"},{"path":"https://ethanancell.github.io/networkinference/reference/split_network.html","id":null,"dir":"Reference","previous_headings":"","what":"Split an adjacency matrix into a train and test adjacency matrix using either data thinning (Poisson or Gaussian edges) or data fission (Bernoulli edges.) — split_network","title":"Split an adjacency matrix into a train and test adjacency matrix using either data thinning (Poisson or Gaussian edges) or data fission (Bernoulli edges.) — split_network","text":"Split adjacency matrix train test adjacency matrix using either data thinning (Poisson Gaussian edges) data fission (Bernoulli edges.)","code":""},{"path":"https://ethanancell.github.io/networkinference/reference/split_network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split an adjacency matrix into a train and test adjacency matrix using either data thinning (Poisson or Gaussian edges) or data fission (Bernoulli edges.) — split_network","text":"","code":"split_network(   A,   distribution,   epsilon = 0.5,   gamma = NULL,   allow_self_loops = TRUE,   is_directed = TRUE,   tau = NULL )"},{"path":"https://ethanancell.github.io/networkinference/reference/split_network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split an adjacency matrix into a train and test adjacency matrix using either data thinning (Poisson or Gaussian edges) or data fission (Bernoulli edges.) — split_network","text":"square adjacency matrix split. distribution distribution edges adjacency matrix follow. Acceptable distributions `\"gaussian\"`, `\"poisson\"`, `\"bernoulli\"`. epsilon parameter controlling amount information allocated train network versus test network. Gaussian Poisson networks, must 0 1 (non-inclusive). larger value epsilon indicates information train network. Bernoulli networks, input alias `gamma` parameter. gamma Bernoulli networks, parameter controlling amount information allocated train network versus test network. must 0 0.5 (non-inclusive) larger value `gamma` indicates less information train network, test network. allow_self_loops logical indicating whether network allows self loops (edges pointing node .) default parameter set `TRUE`. set `FALSE`, values adjacency matrix along diagonal ignored. is_directed logical indicating whether network directed network, default set `TRUE`. set `FALSE`, values along upper triangular portion matrix used. tau networks Gaussian edges , parameter indicates known common standard deviation (square root variance) edges network.","code":""},{"path":"https://ethanancell.github.io/networkinference/reference/split_network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split an adjacency matrix into a train and test adjacency matrix using either data thinning (Poisson or Gaussian edges) or data fission (Bernoulli edges.) — split_network","text":"list labeled two elements labeled `\"Atr\"` `\"Ate\"`, train test networks, respectively.","code":""},{"path":"https://ethanancell.github.io/networkinference/reference/split_network.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split an adjacency matrix into a train and test adjacency matrix using either data thinning (Poisson or Gaussian edges) or data fission (Bernoulli edges.) — split_network","text":"","code":"# Split a simulated Gaussian adjacency matrix A_gaussian <- matrix(rnorm(n = 10^2, mean = 10, sd = 5), nrow = 10) gaussian_split <- split_network(A_gaussian, \"gaussian\", 0.3, tau = 5) A_gaussian_tr <- gaussian_split$Atr A_gaussian_te <- gaussian_split$Ate  # Split a simulated Bernoulli adjacency matrix with gamma = 0.25 A_bernoulli <- matrix(rbinom(n = 10^2, size = 1, p = 0.5), nrow = 10) bernoulli_split <- split_network(A_bernoulli, \"bernoulli\", gamma = 0.25) A_bernoulli_tr <- bernoulli_split$Atr A_bernoulli_te <- bernoulli_split$Ate"}]
